/*HHEADER
       dP                dP       dP                                                 dP         
       88                88       88                                                 88         
       88d888b. .d8888b. 88d888b. 88d888b. .d8888b. .d8888b. .d8888b. .d8888b. .d888b88 .d8888b.
       88'  `88 88'  `88 88'  `88 88'  `88 88ooood8 Y8ooooo. 88'  `"" 88'  `88 88'  `88 88ooood8
       88    88 88.  .88 88.  .88 88.  .88 88.  ...       88 88.  ... 88.  .88 88.  .88 88.  ...
       dP    dP `88888P' 88Y8888' 88Y8888' `88888P' `88888P' `88888P' `88888P' `88888P8 `88888P'


                                                                                                 
                                   i8@@8Li.                t@8000                                
                                 .GitL:::GGGC;             G8ifGt80LtL11,.                       
                                  C,Li;i8i;Ci:ti  i11i:;i::i00ii;;ifffi;;f@8                     
                                  ,L;0L88iCf;L01f.   ,;  ifG0101f0t:;:;;;1GC                     
                                    t@80CL0LfC,    ,1i :;ii CGti1;G8fi::fCiL:                    
                                      L0C11tGf;      ,1;   L .;:.         Lii                    
                                      ,i0fLGt;f1.    t:                    1.                    
                                    ;0C8Li;t88L;:,,i  :t,          :1 .,  .t                     
                                  18i;i;1fC8tL,      .             ,  1. :L                      
                                1C:;G8Gf;f;             ::::      ;LG0t. iLG0CCi                 
            ..t0fC0tGt,       iC:ifCGCt:             ;,    ;L  i G1G0C11CLCL1C88CGti             
          ,Li;G01f01C::GC.   C8G1;:;:;              t           ii8@@@@@C  ;G81iGfitCtt1tf:      
        .CiGtL,      :0:;8: Gi:i08@8.           ..                .ifft,       iL:.       .1     
       .0CLfi          Ct;;08Cffti1.          .,                                f.  i   it:      
       t1i:L            0GLf:::;;;i          ;.                                 i  :.  ;   ::    
       0@@@;            ,iGt:::;:1          f                                    ;; ,i  i1ti     
       C@@@.             18888@@8C         .f     :t11:                               t. i       
       .8@0               G;:::;C8f      :;.L   ,i   , f                                         
                          ff:C8L;;;: t81,:8::f..f    @1 1                                        
                          G0i:::i8L10@8,,ff,f0L0. t@,.f.1                                        
                           C1:18L:i8;88,:Lf8t:f:   : Lt:.                                        
                           ,80C:::8t:L8f:G@G,:L   ,@8  i   ;i.                                   
                            ,8:::t8i::C8C1@8CfG   f@G i ;;    ;1                                 
                              tC:t8f::,;C8C1L0f     .G1f..1 G@,1                                 
                                i0t01::::::f01,f1,iG0;1  Gf    1                                 
                                   :tC00Lt:.      ;G,       8L1.           
                          .LG:;                    f.  f@@1  t.            
                      ,;.0ttC::::                   L   :t: ,:             
                 i;ftttttttt8:::;                    .L.  :1.              
             .:Gtttttfttttttttf;::;                                        
         i8tttttft::Cttttttttt;::::                                        
         tttC,.;;:::::fttttttttt::::;                                      
       ,::1Lt8;:::::::tttttttttt;:::f                                      
     8:0tttttttG;::::::;tttttttttt:::;                                     
   CtfttttttttttG::::::::tttttttttt:::i                                    
   ttttttttttttttt:::::::;tttttttttC:::                                    
    Gtttttttttttttt:::::::Gtttttttttf::t                                   
    .ttttttttttttttt:L.Cii;tttttttttL;f1                                   
     Lttttttttttttttfift,8ttttttttff            
      Gttttttttttttt0fttttttttt,                
       tttttttt1GGttCtLtG8G                     
        .1ft.i,.  t18i           GGGf;;;:::::;::i;:;C 
                t          .ifi:::;:;1fft11if;L11LLf1itC8fi 
                   ;  C8LttttCCLttttttttG1ft1f       
                   :         t                     
                  ;         ;                 Project  >      verdugo
                 L        t                   Version  >      0.0.1
               C       t                      Author   >      llucbrell/Lucas_C
                 8    C                       License  >      MIT
                 ;Ct                          Date     >      2016-08-30

       Workflow build with grunt and nodejs for a better build libraries.
 HHEADER*/


 /*                     __
               _ww   _a+"D
         y#,  _r^ # _*^  y`
        q0 0 a"   W*`    F   ____
     ;  #^ Mw`  __`. .  4-~~^^`
    _  _P   ` /'^           `www=.   ┌─┐┬  ┌─┐┌─┐┌─┐
  ,    +F    `                q      │  │  ├─┤└─┐└─┐
  K ]                         ^K`    └─┘┴─┘┴ ┴└─┘└─┘
, #_                . ___ r    ],    
_*.^            '.__dP^^~#,  ,_ *,    
^b    / _         ``     _F   ]  ]_  
 '___  '               ~~^    ]   [
 :` ]b_    ~k_               ,`  yl   * NAME: Verdugo
   #P        `*a__       __a~   z~`   * in: index.js   
   #L     _      ^------~^`   ,/       _______________________
    ~-vww*"v_               _/`                                 
            ^"q_         _x"                                    
             __#my..___p/`mma____    
         _awP",`,^"-_"^`._ L L  #     
       _#0w_^_^,^r___...._ t [],"w                          
      e^   ]b_x^_~^` __,  .]Wy7` x`     
       '=w__^9*-*MF`      ^[_.=
           ^"y   qw/"^_____^~9 t
             ]_l  ,'^_`..===  x'
              ">.ak__awwwwWW###r
                ##WWWWWWWWWWWWWW__
               _WWWWWWMM#WWWW_JP^"~-=w_
     .____awwmp_wNw#[w/`     ^#,      ~b___.
      ` ^^^~^"W___            ]Raaaamw~`^``^^~
                ^~"~---~~~~~~`              
*/

/** 
 * 
 * Builds a new 3d environment.
 * @class Verdugo
 * @param {JavasCript Object} config - Javascript object with the basic scene, camera, renderer and ligths configurations
 * @default { scene: { color: '' } ,camera:  { position: { x: -50, y: 30, z: -90 } } ,renderer: { setSize: { width: window.innerWidth ,height: window.innerHeight },shadowMapEnabled: true} ,spotLight: { color: 0xffffff ,position: { x: -40 ,y:  60 ,z: -90 } ,castShadow: true }  };
 *
 */
function Verdugo ( config ) {
  // default values for config Object
  this.config = config || { scene: { color: '' }
                           ,camera:  { position: { x: -50
                                                  , y: 30
                                                  , z: -90 } 
                                                   
                                                } 
                           ,renderer: { setSize: { width: window.innerWidth
                                                  ,height: window.innerHeight
                                                  }
                                       ,shadowMap: {Enabled: true}             

                           }
                           ,spotLight: { color: 0xffffff
                                        ,position: {
                                          x: -40
                                         ,y:  60
                                         ,z: -90
                                        }
                                        ,castShadow: true 
                                      } 
                          };
   
   /**
   * 
   * @property {THREE.Scene} scene - a scene, that will hold all our elements such as objects, cameras and lights. 
   *
   */
   this.scene= new THREE.Scene();
   /** use scene.background to set the background color*/
   this.scene.background = new THREE.Color( this.config.scene.color );

   /**
   * 
   * @property {THREE.Camera} camera - a camera, which defines where we're looking at.
   * @default 45,window.innerWidth/window.innerHeight,0.1,1000 -- [-50,30,-90]
   *
   */
   this.camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );
   // position and point the camera to the center of the scene
   this.camera.position.x = this.config.camera.position.x;
   this.camera.position.y = this.config.camera.position.y;
   this.camera.position.z = this.config.camera.position.z;
   this.camera.lookAt( this.scene.position );
   
   /**
   * 
   * @property {THREE.Renderer} renderer - a renderer, which renders all the 3d objects.
   * @default setSize-window.innerWidth, window.innerHeight -- shadowMapEnabled-true
   *
   */
   this.renderer = new THREE.WebGLRenderer();
   // set the default values of the renderer
   //this.renderer.setClearColorHex(new THREE.Color(0xEEEEEE, 1.0)); // changed to transparent by default
   this.renderer.setSize( this.config.renderer.setSize.width, this.config.renderer.setSize.height );
   this.renderer.shadowMap.enabled = this.config.renderer.shadowMap.enabled;

   
   /**
   * 
   * @property {THREE.Spotlight} spotlight - add spotlight for the shadows
   * @default position[-40,60,-90] -- castShadow
   *
   */ 
   this.spotLight = new THREE.SpotLight( this.config.spotLight.color );
   this.spotLight.position.set(  this.config.spotLight.position.x, this.config.spotLight.position.y, this.config.spotLight.position.z );
   this.spotLight.castShadow = this.config.spotLight.castShadow;

   //add spotlight to the scene
   this.scene.add( this.spotLight );
} 

Verdugo.prototype = {
  
    /** 
     * 
     * Attach a web-gl canvas into a user's div.
     * @method renderOn
     * @param {String} divId - the html div id element where the scene will be rendered.
     * 
     */
      renderOn: function ( divId ) { 
            // add the output of the renderer to the html element
              this.config.divId = divId;
              document.getElementById( divId ).appendChild( this.renderer.domElement );
              return this;
            
      }

    /** 
     * 
     * Attach an orbit control camera.
     * @method orbitCam
     *
     * 
     */
    , orbitCam: function (){
     
              this.cameraControls = new THREE.OrbitControls( this.camera );
              return this;
              /*this.viewControl = new Verdugo.View ( this.camera );
              this.viewControl.addEventListener( 'change', this.renderer.render(this.scene, this.camera) ); 
              return this;*/
    }

    /** 
     * 
     * Execute the renderer. Move all elements from the scene to the canvas.
     * @method go
     *
     * 
     */
    , go: function () {   
              // call the render function
              this.renderer.render( this.scene, this.camera );
            }

    /** 
     * 
     * Move all elements from the scene to the canvas and animate the  3d entorn with requestAnimationFrame. 
     * @method goAnim
     *
     * 
     */
    , goAnim: function () {   
              // call the THREEJS render function
              this.renderer.render( this.scene, this.camera );
              // render cameraControls if they'r attached
              if(this.cameraControls) this.cameraControls.update();
              // use of request Animation Frame for render
               requestAnimationFrame( this.goAnim.bind(this) );
               return this;
            }


    /** 
     * 
     * Draws an array of cubes to the scene using the coordinates of the last cube.
     * @method drawCubesTo
     * @param {Array} coordinates - the x,y,z coordinates of the last cube of the array
     * @param {integer} cubeNumbers - the number of cubes that the array is made of
     * @param {integer} size - the longitude of the side of the cubes
     * @param {hexadecimal} hexColor - the color of the cubes
     * @param {String} axe - The directon of the cube's array x', 'y' or 'z' axe. 
     * 
     */
    , drawCubesTo: function ( coordinates, cubeNumbers, size, hexColor, axe ) {
     // variables and default values
      var _positionx 
        , _positiony 
        , _positionz;
          axe = axe || 'x';

            if ( axe==='x' ) {
               _positionx = coordinates[ 0 ] - ( size*cubeNumbers+size );
               _positiony = coordinates[ 1 ];
               _positionz = coordinates[ 2 ];
            }
          
            if ( axe==='y' ) {
               _positionx = coordinates[ 0 ];
               _positiony = coordinates[ 1 ] - ( size*cubeNumbers+size );
               _positionz = coordinates[ 2 ]; 
            }
          
            if ( axe==='z' ) {
               _positionx = coordinates[ 0 ];
               _positiony = coordinates[ 1 ];
               _positionz = coordinates[ 2 ] - ( size*cubeNumbers +size );
            }
          
          
                for ( var i =0; i<cubeNumbers; i++ ) {
                  // create a cube
                  var _cubeGeometry = new THREE.BoxGeometry( size, size, size );
                  var _cubeMaterial = new THREE.MeshLambertMaterial({ color: hexColor });
                  var _cube = new THREE.Mesh( _cubeGeometry, _cubeMaterial );
                  _cube.castShadow = true;
                  _cube.receiveShadow = true;
    
              //actualize the cube position
              if ( axe==='x' ) _positionx += size;
                  
              //actualize the cube position
              if ( axe==='y' ) _positiony += size;
             
              //actualize the cube position
              if ( axe==='z' )  _positionz += size;
    
                
                
              
              // position the cube
              _cube.position.x = _positionx;
              _cube.position.y = _positiony;
              _cube.position.z = _positionz;
    
              // add the cube to the scene
              this.scene.add( _cube );
                }
            return this;

      }          

    /** 
     * 
     * Draws an array of cubes to the scene using the coordinates of the first cube.
     * @method drawCubesFrom
     * @param {Array} initialPosition - the x,y,z coordinates of the first cube of the array
     * @param {integer} cubeNumbers - the number of cubes that the array is made of
     * @param {integer} size - the longitude of the side of the cubes
     * @param {hexadecimal} hexColor - the color of the cubes
     * @param {String} axe - The directon of the cube's array x', 'y' or 'z' axe. 
     * 
     */
    , drawCubesFrom: function ( initialPosition, cubeNumbers, size, hexColor, axe ) {
       var _positionx = initialPosition[ 0 ]
         , _positiony = initialPosition[ 1 ]
         , _positionz = initialPosition[ 2 ];
           axe = axe || 'x';
     
            for ( var i =0; i<cubeNumbers; i++ ) {
              // create a cube
              var _cubeGeometry = new THREE.BoxGeometry( size, size, size );
              var _cubeMaterial = new THREE.MeshLambertMaterial({ color: hexColor });
              var _cube = new THREE.Mesh( _cubeGeometry, _cubeMaterial );
              _cube.castShadow = true;
              _cube.receiveShadow = true;
            //  if(!axe){axe='x'}
     
            // position the cube
            _cube.position.x = _positionx;
            _cube.position.y = _positiony;
            _cube.position.z = _positionz;
     
                
                  //actualize the cube position
                  if ( axe==='x' ) _positionx += size;
                
                  //actualize the cube position
                  if ( axe==='y' ) _positiony += size;               
                 
                  //actualize the cube position
                  if ( axe==='z' ) _positionz += size;
                
     
                // add the cube to the scene
                this.scene.add( _cube );
            }
            return this;

      }

    /** 
     * 
     * Draws an array of cubes to the scene using the coordinates of the first cube.
     * @method drawDiagonalCubesFrom
     * @param {Array} initialPosition - the x,y,z coordinates of the first cube of the array
     * @param {integer} cubeNumbers - the number of cubes that the array is made of
     * @param {integer} size - the longitude of the side of the cubes
     * @param {hexadecimal} hexColor - the color of the cubes
     * @param {String} axe - The directon of the cube's array 'xy', 'yx', 'xz', 'zx', 'yz' or 'zy' axe. 
     * 
     */
    , drawDiagonalCubesFrom: function ( initialPosition, cubeNumbers, size, hexColor, axe ) {
       var _positionx = initialPosition[ 0 ]
         , _positiony = initialPosition[ 1 ]
         , _positionz = initialPosition[ 2 ];
           axe = axe || 'x';
     
            for ( var i =0; i<cubeNumbers; i++ ) {
              // create a cube
              var _cubeGeometry = new THREE.BoxGeometry( size, size, size );
              var _cubeMaterial = new THREE.MeshLambertMaterial({ color: hexColor });
              var _cube = new THREE.Mesh( _cubeGeometry, _cubeMaterial );
              _cube.castShadow = true;
              _cube.receiveShadow = true;
            //  if(!axe){axe='x'}
     
            // position the cube
            _cube.position.x = _positionx;
            _cube.position.y = _positiony;
            _cube.position.z = _positionz;
     
                
                  //actualize the cube position
                  if ( axe==='xy' ) {
                  _positionx += size;
                  _positiony += size;
                  }
                  if ( axe==='yx' ) {
                  _positionx += size;
                  _positiony -= size;
                  }
                
                  //actualize the cube position
                  if ( axe==='xz' ) {
                  _positionx += size;
                  _positionz += size;
                  }
                  if ( axe==='zx' ) {
                  _positionx += size;
                  _positionz -= size;
                  }

                  //actualize the cube position
                  if ( axe==='yz' ) {
                  _positiony += size;
                  _positionz += size;
                  }
                  if ( axe==='zy' ) {
                  _positiony += size;
                  _positionz -= size;
                  }

     
                // add the cube to the scene
                this.scene.add( _cube );
            }
            return this;
       
      }

    /** 
     * 
     * Draws an array of cubes to the scene using the coordinates of the first cube.
     * @method drawDCubesTo
     * @param {Array} coordinates - the x,y,z coordinates of the first cube of the array
     * @param {integer} cubeNumbers - the number of cubes that the array is made of
     * @param {integer} size - the longitude of the side of the cubes
     * @param {hexadecimal} hexColor - the color of the cubes
     * @param {String} axe - The directon of the cube's array 'xy', 'yx', 'xz', 'zx', 'yz' or 'zy' axe. 
     * 
     */
    , drawDiagonalCubesTo: function ( initialPosition, cubeNumbers, size, hexColor, axe ) {
      var _positionx = initialPosition[ 0 ]
         , _positiony = initialPosition[ 1 ]
         , _positionz = initialPosition[ 2 ];
           axe = axe || 'x';
     
            for ( var i =0; i<cubeNumbers; i++ ) {
              // create a cube
              var _cubeGeometry = new THREE.BoxGeometry( size, size, size );
              var _cubeMaterial = new THREE.MeshLambertMaterial({ color: hexColor });
              var _cube = new THREE.Mesh( _cubeGeometry, _cubeMaterial );
              _cube.castShadow = true;
              _cube.receiveShadow = true;
            //  if(!axe){axe='x'}
     
            // position the cube
            _cube.position.x = _positionx;
            _cube.position.y = _positiony;
            _cube.position.z = _positionz;
     
                
                  //actualize the cube position
                  if ( axe==='xy' ) {
                  _positionx -= size;
                  _positiony -= size;
                  }
                  if ( axe==='yx' ) {
                  _positionx -= size;
                  _positiony += size;
                  }
                
                  //actualize the cube position
                  if ( axe==='xz' ) {
                  _positionx -= size;
                  _positionz -= size;
                  }
                  if ( axe==='zx' ) {
                  _positionx -= size;
                  _positionz += size;
                  }

                  //actualize the cube position
                  if ( axe==='yz' ) {
                  _positiony -= size;
                  _positionz -= size;
                  }
                  if ( axe==='zy' ) {
                  _positiony -= size;
                  _positionz += size;
                  }

     
                // add the cube to the scene
                this.scene.add( _cube );
            }
            return this;

      }

    /** 
     * 
     * Draws a cubed line from the coordinates passed to this function.
     * @method drawLineFrom
     * @param {Array} initialPosition - the x,y,z coordinates where the line start
     * @param {integer} long - the longitude of the line
     * @param {integer} width - the width of the line, the other two axes longitude
     * @param {hexadecimal} hexColor - the color of the cubes
     * @param {String} axe - The directon of the line , x, y or z. The longitude it's applied to this parameter 
     * 
     */  
    , drawLineFrom: function ( initialPosition, long, width, hexColor, axe ) { //bug with position
           var _positionx = initialPosition[ 0 ]
             , _positiony = initialPosition[ 1 ]
             , _positionz = initialPosition[ 2 ]
             , _x
             , _y
             , _z;
               axe = axe || 'x';
         
                  //actualize the cube position
                  if ( axe==='x' ) {
                    _x = long;
                    _y = width;
                    _z = width;
                    _positionx= ( ( _positionx - long )/2 ) + width;
                    }
                    
                  //actualize the cube position
                  if ( axe==='y' ) {
                    _x = width;
                    _y = long;
                    _z = width;
                    _positiony= ( ( _positiony - long/2 ) ) +width -2; //maybe works for fixing bug

                    } 
                
                  //actualize the cube position
                  if ( axe==='z' ) {
                    _x = width;
                    _y = width;
                    _z = long;
                    _positionz= ( ( _positionz - long )/2 ) +width;

                    }
                  // create a cube
                  var _cubeGeometry = new THREE.BoxGeometry( _x, _y, _z );
                  var _cubeMaterial = new THREE.MeshLambertMaterial({ color: hexColor });
                  var _cube = new THREE.Mesh( _cubeGeometry, _cubeMaterial );
                  _cube.castShadow = true;
                  _cube.receiveShadow = true;
                //  if(!axe){axe='x'}
         
                // position the cube
                _cube.position.x = _positionx;
                _cube.position.y = _positiony;
                _cube.position.z = _positionz;
                    
         
                    // add the cube to the scene
                    this.scene.add( _cube );

                    return this;

                
      }

    /** 
     * 
     * Draws a cubed line to the coordinates passed to this function.
     * @method drawLineTo
     * @param {Array} initialPosition - the x,y,z coordinates where the line start
     * @param {integer} long - the longitude of the line
     * @param {integer} width - the width of the line, the other two axes longitude
     * @param {hexadecimal} hexColor - the color of the cubes
     * @param {String} axe - The directon of the line , x, y or z. The longitude it's applied to this parameter 
     * 
     */
    , drawLineTo: function ( finalPosition, long, width, hexColor, axe ) { // THERE IS A BUG WITH THIS METHOD
           var _positionx = finalPosition[ 0 ]
             , _positiony = finalPosition[ 1 ]
             , _positionz = finalPosition[ 2 ]
             , _x
             , _y
             , _z;
               axe = axe || 'x';
         

                  //actualize the cube position
                  if ( axe==='x' ) {
                    _x = long;
                    _y = width;
                    _z = width;
                    _positionx= ( ( _positionx + long )/2 ) + width; //correct width coordinates desviation
                    }
                    
                  //actualize the cube position
                  if ( axe==='y' ) {
                    _x = width;
                    _y = long;
                    _z = width;
                    _positiony= ( ( _positiony + long )/2 ) +width;

                    } 
                
                  //actualize the cube position
                  if ( axe==='z' ) {
                    _x = width;
                    _y = width;
                    _z = long;
                    _positionz= ( ( _positionz + long )/2 ) +width;

                    }
                  // create a cube
                  var _cubeGeometry = new THREE.BoxGeometry( _x, _y, _z );
                  var _cubeMaterial = new THREE.MeshLambertMaterial({ color: hexColor });
                  var _cube = new THREE.Mesh( _cubeGeometry, _cubeMaterial );
                  _cube.castShadow = true;
                  _cube.receiveShadow = true;
                //  if(!axe){axe='x'}
         
                // position the cube
                _cube.position.x = _positionx;
                _cube.position.y = _positiony;
                _cube.position.z = _positionz;
                    
         
                    // add the cube to the scene
                    this.scene.add( _cube );

                    return this;

                
      }

    /** 
     * 
     * Draws a cube with coordinates stablished from the center of the cube.
     * @method drawFromCenterCube
     * @param {Array} position - the x,y,z coordinates where the cube is drawn
     * @param {float} longX - the longitude of the x side of the cube
     * @param {float} longY - the longitude of the y side of the cube
     * @param {float} longZ - the longitude of the z side of the cube
     * @param {hexadecimal} hexColor - the color of the cubes
     * 
     */
      , drawFromCenterCube: function ( finalPosition, longX, longY, longZ, hexColor ) {
          var _positionx = finalPosition[ 0 ]
            , _positiony = finalPosition[ 1 ]
            , _positionz = finalPosition[ 2 ];
                // create a cube
                  var _cubeGeometry = new THREE.BoxGeometry( longX, longY, longZ );
                  var _cubeMaterial = new THREE.MeshLambertMaterial({ color: hexColor });
                  var _cube = new THREE.Mesh( _cubeGeometry, _cubeMaterial );
                  _cube.castShadow = true;
                  _cube.receiveShadow = true;

                   // position the cube
                _cube.position.x = _positionx;
                _cube.position.y = _positiony;
                _cube.position.z = _positionz;
                    
         
                    // add the cube to the scene
                    this.scene.add( _cube );
                    
                    return this;


      }

    /** 
     * 
     * Draws a specified positioned cube with coordinates stablished from left-upper point.
     * @method drawCube
     * @param {Array} position - the x,y,z coordinates where the line start
     * @param {float} longX - the longitude of the x side of the cube
     * @param {float} longY - the longitude of the y side of the cube
     * @param {float} longZ - the longitude of the z side of the cube
     * @param {hexadecimal} hexColor - the color of the cubes
     * 
     */
      , drawCube: function ( position, longX, longY, longZ, hexColor ) {
                  var _positionx = position[ 0 ]
                    , _positiony = position[ 1 ]
                    , _positionz = position[ 2 ];
                        // create a cube
                          var _cubeGeometry = new THREE.BoxGeometry( longX, longY, longZ );
                          var _cubeMaterial = new THREE.MeshLambertMaterial({ color: hexColor });
                          var _cube = new THREE.Mesh( _cubeGeometry, _cubeMaterial );
                          _cube.castShadow = true;
                          _cube.receiveShadow = true;

                        // position the cube 
                        // with this formula we can ajust the coordinates of the cube to match with the rest of methods 
                        _cube.position.x = ( ( _positionx + ( longX/2 ) - 2 ) );
                        _cube.position.y = ( ( _positiony + ( longY/2 ) - 2 ) );
                        _cube.position.z = ( ( _positionz + ( longZ/2 ) - 2 ) );
                            
                 
                            // add the cube to the scene
                            this.scene.add( _cube );
                            return this;


      }

      , drawSphere: function ( position, radius, widthSegments, heightSegments , hexColor ) {
                  var _positionx = position[ 0 ]
                    , _positiony = position[ 1 ]
                    , _positionz = position[ 2 ];
                        // create a cube
                          var _sphereGeometry = new THREE.SphereGeometry( radius, widthSegments, heightSegments );
                          var _sphereMaterial = new THREE.MeshLambertMaterial({ color: hexColor });
                          var _sphere = new THREE.Mesh( _sphereGeometry, _sphereMaterial );
                          _sphere.castShadow = true;
                          _sphere.receiveShadow = true;

                        // position the cube 
                        // with this formula we can ajust the coordinates of the cube to match with the rest of methods 
                        _sphere.position.x = ( _positionx  );
                        _sphere.position.y = ( _positiony  );
                        _sphere.position.z = ( _positionz  );
                            
                 
                            // add the cube to the scene
                            this.scene.add( _sphere );
                            return this;


      }
              

};

/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 *
 */
/*global THREE, console */

// This set of controls performs orbiting, dollying (zooming), and panning. It maintains
// the "up" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is
// supported.
//
//    Orbit - left mouse / touch: one finger move
//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
//    Pan - right mouse, or arrow keys / touch: three finter swipe
//
// This is a drop-in replacement for (most) TrackballControls used in examples.
// That is, include this js file and wherever you see:
//      controls = new THREE.TrackballControls( camera );
//      controls.target.z = 150;
// Simple substitute "OrbitControls" and the control should work as-is.
console.log('h5');

THREE.OrbitControls = function ( object, domElement ) {

  this.object = object;
  this.domElement = ( domElement !== undefined ) ? domElement : document;

  // API

  // Set to false to disable this control
  this.enabled = true;

  // "target" sets the location of focus, where the control orbits around
  // and where it pans with respect to.
  this.target = new THREE.Vector3();
  // center is old, deprecated; use "target" instead
  this.center = this.target;

  // This option actually enables dollying in and out; left as "zoom" for
  // backwards compatibility
  this.noZoom = false;
  this.zoomSpeed = 1.0;
  // Limits to how far you can dolly in and out
  this.minDistance = 0;
  this.maxDistance = Infinity;

  // Set to true to disable this control
  this.noRotate = false;
  this.rotateSpeed = 1.0;

  // Set to true to disable this control
  this.noPan = false;
  this.keyPanSpeed = 7.0; // pixels moved per arrow key push

  // Set to true to automatically rotate around the target
  this.autoRotate = false;
  this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

  // How far you can orbit vertically, upper and lower limits.
  // Range is 0 to Math.PI radians.
  this.minPolarAngle = 0; // radians
  this.maxPolarAngle = Math.PI; // radians

  // Set to true to disable use of the keys
  this.noKeys = false;
  // The four arrow keys
  this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

  ////////////
  // internals

  var scope = this;

  var EPS = 0.000001;

  var rotateStart = new THREE.Vector2();
  var rotateEnd = new THREE.Vector2();
  var rotateDelta = new THREE.Vector2();

  var panStart = new THREE.Vector2();
  var panEnd = new THREE.Vector2();
  var panDelta = new THREE.Vector2();

  var dollyStart = new THREE.Vector2();
  var dollyEnd = new THREE.Vector2();
  var dollyDelta = new THREE.Vector2();

  var phiDelta = 0;
  var thetaDelta = 0;
  var scale = 1;
  var pan = new THREE.Vector3();

  var lastPosition = new THREE.Vector3();

  var STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };
  var state = STATE.NONE;

  // events

  var changeEvent = { type: 'change' };


  this.rotateLeft = function ( angle ) {

    if ( angle === undefined ) {

      angle = getAutoRotationAngle();

    }

    thetaDelta -= angle;

  };

  this.rotateUp = function ( angle ) {

    if ( angle === undefined ) {

      angle = getAutoRotationAngle();

    }

    phiDelta -= angle;

  };

  // pass in distance in world space to move left
  this.panLeft = function ( distance ) {

    var panOffset = new THREE.Vector3();
    var te = this.object.matrix.elements;
    // get X column of matrix
    panOffset.set( te[0], te[1], te[2] );
    panOffset.multiplyScalar(-distance);
    
    pan.add( panOffset );

  };

  // pass in distance in world space to move up
  this.panUp = function ( distance ) {

    var panOffset = new THREE.Vector3();
    var te = this.object.matrix.elements;
    // get Y column of matrix
    panOffset.set( te[4], te[5], te[6] );
    panOffset.multiplyScalar(distance);
    
    pan.add( panOffset );
  };
  
  // main entry point; pass in Vector2 of change desired in pixel space,
  // right and down are positive
  this.pan = function ( delta ) {

    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

    if ( scope.object.fov !== undefined ) {

      // perspective
      var position = scope.object.position;
      var offset = position.clone().sub( scope.target );
      var targetDistance = offset.length();

      // half of the fov is center to top of screen
      targetDistance *= Math.tan( (scope.object.fov/2) * Math.PI / 180.0 );
      // we actually don't use screenWidth, since perspective camera is fixed to screen height
      scope.panLeft( 2 * delta.x * targetDistance / element.clientHeight );
      scope.panUp( 2 * delta.y * targetDistance / element.clientHeight );

    } else if ( scope.object.top !== undefined ) {

      // orthographic
      scope.panLeft( delta.x * (scope.object.right - scope.object.left) / element.clientWidth );
      scope.panUp( delta.y * (scope.object.top - scope.object.bottom) / element.clientHeight );

    } else {

      // camera neither orthographic or perspective - warn user
      console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );

    }

  };

  this.dollyIn = function ( dollyScale ) {

    if ( dollyScale === undefined ) {

      dollyScale = getZoomScale();

    }

    scale /= dollyScale;

  };

  this.dollyOut = function ( dollyScale ) {

    if ( dollyScale === undefined ) {

      dollyScale = getZoomScale();

    }

    scale *= dollyScale;

  };

  this.update = function () {

    var position = this.object.position;
    var offset = position.clone().sub( this.target );

    // angle from z-axis around y-axis

    var theta = Math.atan2( offset.x, offset.z );

    // angle from y-axis

    var phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );

    if ( this.autoRotate ) {

      this.rotateLeft( getAutoRotationAngle() );

    }

    theta += thetaDelta;
    phi += phiDelta;

    // restrict phi to be between desired limits
    phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );

    // restrict phi to be betwee EPS and PI-EPS
    phi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );

    var radius = offset.length() * scale;

    // restrict radius to be between desired limits
    radius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );
    
    // move target to panned location
    this.target.add( pan );

    offset.x = radius * Math.sin( phi ) * Math.sin( theta );
    offset.y = radius * Math.cos( phi );
    offset.z = radius * Math.sin( phi ) * Math.cos( theta );

    position.copy( this.target ).add( offset );

    this.object.lookAt( this.target );

    thetaDelta = 0;
    phiDelta = 0;
    scale = 1;
    pan.set(0,0,0);

    if ( lastPosition.distanceTo( this.object.position ) > 0 ) {

      this.dispatchEvent( changeEvent );

      lastPosition.copy( this.object.position );

    }

  };


  function getAutoRotationAngle() {

    return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

  }

  function getZoomScale() {

    return Math.pow( 0.95, scope.zoomSpeed );

  }

  function onMouseDown( event ) {

    if ( scope.enabled === false ) { return; }
    event.preventDefault();

    if ( event.button === 0 ) {
      if ( scope.noRotate === true ) { return; }

      state = STATE.ROTATE;

      rotateStart.set( event.clientX, event.clientY );

    } else if ( event.button === 1 ) {
      if ( scope.noZoom === true ) { return; }

      state = STATE.DOLLY;

      dollyStart.set( event.clientX, event.clientY );

    } else if ( event.button === 2 ) {
      if ( scope.noPan === true ) { return; }

      state = STATE.PAN;

      panStart.set( event.clientX, event.clientY );

    }

    // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be
    scope.domElement.addEventListener( 'mousemove', onMouseMove, false );
    scope.domElement.addEventListener( 'mouseup', onMouseUp, false );

  }

  function onMouseMove( event ) {

    if ( scope.enabled === false ) return;

    event.preventDefault();

    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

    if ( state === STATE.ROTATE ) {

      if ( scope.noRotate === true ) return;

      rotateEnd.set( event.clientX, event.clientY );
      rotateDelta.subVectors( rotateEnd, rotateStart );

      // rotating across whole screen goes 360 degrees around
      scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );
      // rotating up and down along whole screen attempts to go 360, but limited to 180
      scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

      rotateStart.copy( rotateEnd );

    } else if ( state === STATE.DOLLY ) {

      if ( scope.noZoom === true ) return;

      dollyEnd.set( event.clientX, event.clientY );
      dollyDelta.subVectors( dollyEnd, dollyStart );

      if ( dollyDelta.y > 0 ) {

        scope.dollyIn();

      } else {

        scope.dollyOut();

      }

      dollyStart.copy( dollyEnd );

    } else if ( state === STATE.PAN ) {

      if ( scope.noPan === true ) return;

      panEnd.set( event.clientX, event.clientY );
      panDelta.subVectors( panEnd, panStart );
      
      scope.pan( panDelta );

      panStart.copy( panEnd );

    }

    // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be
    scope.update();

  }

  function onMouseUp( /* event */ ) {

    if ( scope.enabled === false ) return;

    // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be
    scope.domElement.removeEventListener( 'mousemove', onMouseMove, false );
    scope.domElement.removeEventListener( 'mouseup', onMouseUp, false );

    state = STATE.NONE;

  }

  function onMouseWheel( event ) {

    if ( scope.enabled === false || scope.noZoom === true ) return;

    var delta = 0;

    if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9

      delta = event.wheelDelta;

    } else if ( event.detail ) { // Firefox

      delta = - event.detail;

    }

    if ( delta > 0 ) {

      scope.dollyOut();

    } else {

      scope.dollyIn();

    }

  }

  function onKeyDown( event ) {

    if ( scope.enabled === false ) { return; }
    if ( scope.noKeys === true ) { return; }
    if ( scope.noPan === true ) { return; }

    // pan a pixel - I guess for precise positioning?
    // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be
    var needUpdate = false;
    
    switch ( event.keyCode ) {

      case scope.keys.UP:
        scope.pan( new THREE.Vector2( 0, scope.keyPanSpeed ) );
        needUpdate = true;
        break;
      case scope.keys.BOTTOM:
        scope.pan( new THREE.Vector2( 0, -scope.keyPanSpeed ) );
        needUpdate = true;
        break;
      case scope.keys.LEFT:
        scope.pan( new THREE.Vector2( scope.keyPanSpeed, 0 ) );
        needUpdate = true;
        break;
      case scope.keys.RIGHT:
        scope.pan( new THREE.Vector2( -scope.keyPanSpeed, 0 ) );
        needUpdate = true;
        break;
    }

    // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be
    if ( needUpdate ) {

      scope.update();

    }

  }
  
  function touchstart( event ) {

    if ( scope.enabled === false ) { return; }

    switch ( event.touches.length ) {

      case 1: // one-fingered touch: rotate
        if ( scope.noRotate === true ) { return; }

        state = STATE.TOUCH_ROTATE;

        rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
        break;

      case 2: // two-fingered touch: dolly
        if ( scope.noZoom === true ) { return; }

        state = STATE.TOUCH_DOLLY;

        var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
        var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
        var distance = Math.sqrt( dx * dx + dy * dy );
        dollyStart.set( 0, distance );
        break;

      case 3: // three-fingered touch: pan
        if ( scope.noPan === true ) { return; }

        state = STATE.TOUCH_PAN;

        panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
        break;

      default:
        state = STATE.NONE;

    }
  }

  function touchmove( event ) {

    if ( scope.enabled === false ) { return; }

    event.preventDefault();
    event.stopPropagation();

    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

    switch ( event.touches.length ) {

      case 1: // one-fingered touch: rotate
        if ( scope.noRotate === true ) { return; }
        if ( state !== STATE.TOUCH_ROTATE ) { return; }

        rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
        rotateDelta.subVectors( rotateEnd, rotateStart );

        // rotating across whole screen goes 360 degrees around
        scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );
        // rotating up and down along whole screen attempts to go 360, but limited to 180
        scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

        rotateStart.copy( rotateEnd );
        break;

      case 2: // two-fingered touch: dolly
        if ( scope.noZoom === true ) { return; }
        if ( state !== STATE.TOUCH_DOLLY ) { return; }

        var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
        var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
        var distance = Math.sqrt( dx * dx + dy * dy );

        dollyEnd.set( 0, distance );
        dollyDelta.subVectors( dollyEnd, dollyStart );

        if ( dollyDelta.y > 0 ) {

          scope.dollyOut();

        } else {

          scope.dollyIn();

        }

        dollyStart.copy( dollyEnd );
        break;

      case 3: // three-fingered touch: pan
        if ( scope.noPan === true ) { return; }
        if ( state !== STATE.TOUCH_PAN ) { return; }

        panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
        panDelta.subVectors( panEnd, panStart );
        
        scope.pan( panDelta );

        panStart.copy( panEnd );
        break;

      default:
        state = STATE.NONE;

    }

  }

  function touchend( /* event */ ) {

    if ( scope.enabled === false ) { return; }

    state = STATE.NONE;
  }

  this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
  this.domElement.addEventListener( 'mousedown', onMouseDown, false );
  this.domElement.addEventListener( 'mousewheel', onMouseWheel, false );
  this.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox

  this.domElement.addEventListener( 'keydown', onKeyDown, false );

  this.domElement.addEventListener( 'touchstart', touchstart, false );
  this.domElement.addEventListener( 'touchend', touchend, false );
  this.domElement.addEventListener( 'touchmove', touchmove, false );

};

THREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );



/*HFOOTER
888               888       888                                                       888     
888               888       888                                                       888      
888               888       888                                                       888       
888-~88e  e88~-_  888-~88e  888-~88e   e88~~8e   d88~  e88~~  e88~~  e88~-_   e88~888  e88~~8e 
888  888 d888   i 888  888b 888  888b d888  88b C888   d888    d888    d888   i d888  888 d888  88b 
888  888 8888   | 888  8888 888  8888 8888__888  Y88b  8888    8888    8888   | 8888  888 8888__888 
888  888 Y888   ' 888  888P 888  888P Y888    ,   888D Y888    Y888    Y888   ' Y888  888 Y888    , 
888  888  "88_-~  888-_88"  888-_88"   "88___/  _88P   "88__/  "88__/  "88_-~   "88_/888  "88___/  
                        
                                                                        copyright llucbrell/Lucas_C
                                                                           hobbescode@gmail.com 
               :088C;                                                  
          ,008000LtCCt.  it;1;tC00G00LfLG0t                            
         :800808000Gt.t0GCCGGG00L; ...:tLCt1tt0G,                      
          i0800LCL880C.,;  fG0t                ,8G0G000GC,             
          ;0080C.    .    f0C                   ,80000GG00;            
           :8080GftC.                .           .; 1GfGGLi            
             ,LG80C.             1G1 .0C; .1CCG1    :8GL0L.            
               .C800Gf:        ,t. 1   G0fL.C  Cf    ;                 
              18@0G80GCf     ::   :0G0 1t  :0G t1   i,                 
               t01     L     ,i         t:      ,L ..11                
            .Gti@.1i ,C1C    ;         ;1       11:GG0f                
         .1C1..L8018C8C0:    f        1G;      :L   ,Lf                
          ,C0t  ;C,CG000    1       C,fi      G     C.                 
      18G1            :C,   1,   ,LGCG01    .Gt  LftL                  
        :1f01                 .f08080G00Gtf0L, fC0080G1                
      tC1;                  :0LLt,.,,,,tL0G.    ;:t8C.                 
     C808Lt10,              @G f800G88881 1G:      ;C0C0C.             
          i0                i0808808088C81;GC       ff:                
        ;01:i1:               f0000GG008000G.        ;ff,              
        :f1. 1i                 .f@0000000,        ii   .              
           iG.                                      .1f.               
          ,1CG88L     :       .                 ,   it,                
                 .tt, tt      i1;;f0L          :,i0L:                  
               .i:    ,;L:                 G:   ,t                     
                        .G0t,           .f0  i;  ;:                    
                 tCGL       i@8G0LLLLC80f,. L                          
              ,LG1:            ..,,,.                                  
              18G000GGL.            .1.                                
             LG;    .;LG           ft                                  
             G8i      ,fGL         1G:                                 
         .1G0G800CCG0G0i             1t;.                              
         .GGG0GGGCGCG0G0,            :Cf;.                             
          f0C        .GL            ;10L                               
         fGG.       if                ;C;                              
         100GG00C;,Ct;:.           .0f,if1                             
        .G0CGG08L000:GL.            :C.                                
        10G  ,1CG00GG:               .Ci       
 HFOOTER*/